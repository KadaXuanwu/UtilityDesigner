\chapter{Introduction}
\label{chap:introduction}

The demand for intelligent AI in video games is growing as people want to feel more and more immersed in the virtual environment. Not only are realistic graphics important, but also lifelike NPCs that behave as closely as possible to a real person or animal. Over the past few years, several solutions have been developed to address this problem, the most well-known of which are state machines and behaviour trees. Being very flexible and intuitive, behaviour trees have proven to be a good choice for creating NPC behaviours. However, they can become rigid and overly complex when dealing with scenarios where the NPC has to make decisions in a dynamic environment, a necessity for realistic behaviour.

A less common concept called utility AI has also been around for a few years and seems to offer a solution to making lifelike NPCs easier. It uses some information about the current state of the game to let the NPC decide what is the best action to take given the circumstances. Utility AI's relative novelty and mathematical complexity have hindered its widespread adoption. In contrast, behaviour trees, with their rich documentation and seamless integration into popular tools, remain the first choice for many developers.

This paper describes the work from the thesis, but also includes some chapters from Projects 2. Specifically, the chapters \ref{chap:projectevolution}, \ref{chap:behaviourtrees}, \ref{chap:utilityai} and \ref{chap:comparisontoothersolutions} were originally part of Project 2 and have been slightly adapted to fit into this thesis. The scope of the thesis was to use the idea of utility AI explored in Projects 2 to create a generic and intuitive tool with a graphical interface for Unity, using Unity's UI toolkit. Utility AI acts as a high-level decision making mechanism, but it needs the help of another system that defines the exact execution of the decisions made. Since utility AI as a standalone solution is not sufficient in most situations, it is also part of the scope of this thesis to provide an implementation of a second solution that helps support the utility AI part. The combination of utility AI and a suitable solution allows for a very flexible and extensible tool that helps developers to create intelligent and realistic NPCs with ease. The tool must also provide a way for developers to analyse its behaviour at runtime by displaying different states and values in the editor window. In order to check if the tool works well, some test scenes need to be created that show real-life examples of how the tool can be used, and improvements can be made based on the results.

One of the main goals of this thesis is to make utility AI accessible to everyone, so that more people can get to know it. Unity has an asset store that allows any developer to upload or download assets, making it the perfect place to spread the idea of utility AI with a clean tool to implement it. There are already good assets for other solutions like state machines or behaviour trees, but not so much for utility AI. The tool created in this thesis is called Utility Designer and aims to fill this gap in the Unity Asset Store.

There are many requirements for a good tool. It must be easy to use, efficient and easy to maintain. Genericity is crucial to ensure adaptability to different use cases, but it must still provide discrete help to developers to speed up their work. Flexibility and debugging support are key, along with solid documentation and examples. The development process of Utility Designer aims to meet these requirements as well as possible in order to stand out as a good asset. It is also necessary to decide which solution works best in combination with utility AI.

Chapter \ref{chap:projectevolution} gives a quick overview of how the project idea was developed. The chapters \ref{chap:behaviourtrees}, \ref{chap:utilityai} and \ref{chap:comparisontoothersolutions} are used to describe the different solutions used in game development for creating NPCs, and provide a comparison between them to determine the best use case for each. The following chapter explains the tool created for this thesis, its use cases and some example scenes. The manual on how to use it can be found in the appendix and is not described in the \ref{chap:utilitydesigner} chapter itself. Chapter \ref{chap:performance} gives a deeper insight into the performance of the tool and how it performs when 1000 NPCs are using it at the same time.